<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
    <channel>
        <title>LinuxJedi's /dev/null</title>
        <link>http://linuxjedi.co.uk/blog/html/</link>
        <description>The /dev/null ramblings of a Linux Jedi</description>
        <language>en-us</language>
        <pubDate>Fri, 03 Oct 2014 00:00:00 +0100</pubDate>
        
        <item>
            <link>http://linuxjedi.co.uk/blog/html/2014/10/03/libattachsql_benchmarks_with_sysbench.html</link>
            <guid>http://linuxjedi.co.uk/blog/html/2014/10/03/libattachsql_benchmarks_with_sysbench.html</guid>
            <title><![CDATA[libAttachSQL Benchmarks With Sysbench]]></title>
            <description><![CDATA[<h1>libAttachSQL Benchmarks With Sysbench</h1>
<p>This week I have been spending a little bit of time creating a module for <a class="reference external" href="https://launchpad.net/sysbench">Sysbench</a> so that it can use <a class="reference external" href="http://libattachsql.org">libAttachSQL</a> as a database driver.  The reason for doing this is twofold:</p>
<ol class="arabic simple">
<li><a class="reference external" href="http://krow.net">Brian</a> (my boss at HP’s Advanced Technology Group) said now would be a good time to benchmark libAttachSQL</li>
<li>I really needed more than a few basic queries to shake out bugs in the library, and a benchmark is a good way to shove a few million through it</li>
</ol>
<p>On the bug front, it did find a total of 5 bugs, a couple of them serious.  Which is great, the more testing and bug finding the better.  These have all been fixed in <a class="reference external" href="http://github.com/libattachsql/libattachsql">GitHub</a> and will be part of the upcoming 0.5.0 release.</p>
<div class="section" id="the-test-setup">
<h2>The Test Setup</h2>
<p>To benchmark I used an HP Z620, 6-core Xeon with 16GB RAM and an SSD.  The OS was Antergos Linux (Arch with a nicer theme) and the server was MySQL 5.6.20 compiled from source.  The only real tweaks I’ve made to the out-of-box config that would make any difference are:</p>
<div class="highlight-ini"><div class="highlight"><pre><span class="na">innodb_buffer_pool_size</span><span class="o">=</span><span class="s">3G</span>
<span class="na">innodb_locks_unsafe_for_binlog</span><span class="o">=</span><span class="s">1</span>
<span class="na">innodb_buffer_pool_instances</span><span class="o">=</span><span class="s">8</span>
<span class="na">thread_cache</span><span class="o">=</span><span class="s">256</span>
<span class="na">query_cache_type</span><span class="o">=</span><span class="s">0</span>
<span class="na">query_cache_size</span><span class="o">=</span><span class="s">0</span>
<span class="na">max_connections</span><span class="o">=</span><span class="s">20020</span>
<span class="na">max_user_connections</span><span class="o">=</span><span class="s">20000</span>
</pre></div>
</div>
<p>The <a class="reference external" href="https://github.com/libattachsql/sysbench">Sysbench in libAttachSQL’s GitHub</a> was used which just has the additional driver for libAttachSQL.  Once I’m 100% happy with the driver I offer it as an upstream branch.  libAttachSQL master is used, partly due to the bug fixes and partly because there has been a large API change in master for improved error handling.</p>
<p>For both libmysqlclient and libAttachSQL the connections were made using Unix Domain Sockets.  For the sysbench setup I just left it at the default number of rows.  The Sysbench driver for libAttachSQL enables the semi-blocking mode which is better performance for single-connection-per-thread applications.</p>
</div>
<div class="section" id="select-test">
<h2>Select Test</h2>
<p>First the basic select test was run, which queries for random single integers in a table.  This was run with the MySQL driver as follows:</p>
<div class="highlight-bash"><div class="highlight"><pre>sysbench --test<span class="o">=</span>sysbench/tests/db/select.lua --db-driver<span class="o">=</span>mysql --mysql-socket<span class="o">=</span>/tmp/mysql.sock --mysql-user<span class="o">=</span><span class="nb">test</span> --mysql-password<span class="o">=</span><span class="nb">test</span> --mysql-db<span class="o">=</span>testdb --num-threads<span class="o">=</span>8 --max-requests<span class="o">=</span>1000000 run
</pre></div>
</div>
<p>And libAttachSQL:</p>
<div class="highlight-bash"><div class="highlight"><pre>sysbench --test<span class="o">=</span>sysbench/tests/db/select.lua --db-driver<span class="o">=</span>attachsql --attachsql-socket<span class="o">=</span>/tmp/mysql.sock --attachsql-user<span class="o">=</span><span class="nb">test</span> --attachsql-password<span class="o">=</span><span class="nb">test</span> --attachsql-db<span class="o">=</span>testdb --num-threads<span class="o">=</span>8 --max-requests<span class="o">=</span>1000000 run
</pre></div>
</div>
<p>The results were as follows:</p>
<img alt="../../../_images/select_benchmark.png" src="http://linuxjedi.co.uk/blog/html/_images/select_benchmark.png"/>
<p>I am pretty impressed with these results so far, since I have done no optimisation work on the code.  I originally wanted the first GA to have performance on-par with libmysqlclient and it looks like that goal has been met.</p>
</div>
<div class="section" id="select-random-points">
<h2>Select Random Points</h2>
<p>I used the “Select Random Points” benchmark because it is one of the only ones that comes with Sysbench which uses Prepared Statements.  It selects 10 random integers from a table per query.</p>
<p>As before this was run on using libmysqlclient with:</p>
<div class="highlight-bash"><div class="highlight"><pre>sysbench --test<span class="o">=</span>sysbench/tests/db/select_random_points.lua --db-driver<span class="o">=</span>mysql --mysql-socket<span class="o">=</span>/tmp/mysql.sock --mysql-user<span class="o">=</span><span class="nb">test</span> --mysql-password<span class="o">=</span><span class="nb">test</span> --mysql-db<span class="o">=</span>testdb --num-threads<span class="o">=</span>8 --max-requests<span class="o">=</span>1000000 run
</pre></div>
</div>
<p>And with libAttachSQL:</p>
<div class="highlight-bash"><div class="highlight"><pre>sysbench --test<span class="o">=</span>sysbench/tests/db/select_random_points.lua --db-driver<span class="o">=</span>attachsql --attachsql-socket<span class="o">=</span>/tmp/mysql.sock --attachsql-user<span class="o">=</span><span class="nb">test</span> --attachsql-password<span class="o">=</span><span class="nb">test</span> --attachsql-db<span class="o">=</span>testdb --num-threads<span class="o">=</span>8 --max-requests<span class="o">=</span>1000000 run
</pre></div>
</div>
<p>The results were as follows:</p>
<img alt="../../../_images/select_random_points_benchmark.png" src="http://linuxjedi.co.uk/blog/html/_images/select_random_points_benchmark.png"/>
<p>Again there isn’t a lot in it.  libmysqlclient is edging slightly over libAttachSQL in most of this chart.  I believe it is because in the libAttachSQL driver I told it to convert all results to string outputs.  This will add additional overhead.  Next week I will tweak the driver to make sure that the conversion isn’t done.</p>
</div>
<div class="section" id="conclusion">
<h2>Conclusion</h2>
<p>I’m very happy with these Sysbench tests because not only has it bashed libAttachSQL with a sledgehammer it has given me some idea of the performance.  I’m happy enough with these figures to not do any performance tuning until after the first GA release.</p>
<p>At some point soon I will also benchmark the single-threaded multi-connection performance of libAttachSQL.  This is not something I can easily compare to libmysqlclient (there is an API to do it, but it is an unofficial/unsupported API).  But it will be a good test for the use case I originally designed the library for.</p>
<p>I am no benchmarking expert and I know many of you who reading this are (especially Percona).  Is there anything I missed or could have done better?  Please let me know in the comments.</p>
</div>
]]></description>
            <category><![CDATA[ MySQL ]]></category>
            <category><![CDATA[ libAttachSQL ]]></category>
             <pubDate>Fri, 03 Oct 2014 00:00:00 +0100</pubDate>
        </item>
    
        <item>
            <link>http://linuxjedi.co.uk/blog/html/2014/09/23/libattachsql_query_example.html</link>
            <guid>http://linuxjedi.co.uk/blog/html/2014/09/23/libattachsql_query_example.html</guid>
            <title><![CDATA[libAttachSQL Query Example]]></title>
            <description><![CDATA[<h1>libAttachSQL Query Example</h1>
<p>I was asked some questions on IRC last night about how the query example in libAttachSQL’s code base works.  For those who missed previous posts, <a class="reference external" href="http://libattachsql.org">libAttachSQL</a> is a lightweight, non-blocking, Apache 2.0 licensed C connector for MySQL servers which I am developing for HP’s Advanced Technology Group.</p>
<p>In this blog post I’m going to break down <a class="reference external" href="https://github.com/libattachsql/libattachsql/blob/master/examples/basic_query.c">a basic query example</a> and explain what is happening at each step. It is possible that this syntax may change slightly by the time we hit GA but it will be similar to this.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#include &lt;libattachsql-1.0/attachsql.h&gt;</span>
<span class="cp">#include &lt;stddef.h&gt;</span>
<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;string.h&gt;</span>
</pre></div>
</div>
<p>Only one include is needed for the library itself, <span class="docutils literal"><span class="pre">libattachsql-1.0/attachsql.h</span></span>. The others are used for other functions in the code.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="kt">attachsql_connect_t</span> <span class="o">*</span><span class="n">con</span><span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="n">attachsql_error_st</span> <span class="o">*</span><span class="n">error</span><span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">query</span><span class="o">=</span> <span class="s">"SELECT * FROM t1 WHERE name='fred'"</span><span class="p">;</span>
  <span class="kt">attachsql_return_t</span> <span class="n">ret</span><span class="o">=</span> <span class="n">ATTACHSQL_RETURN_NONE</span><span class="p">;</span>
  <span class="n">attachsql_query_row_st</span> <span class="o">*</span><span class="n">row</span><span class="p">;</span>
  <span class="kt">uint16_t</span> <span class="n">columns</span><span class="p">,</span> <span class="n">current_column</span><span class="p">;</span>
</pre></div>
</div>
<p>Here we have setup a few required variables:</p>
<ul class="simple">
<li><span class="docutils literal"><span class="pre">con</span></span> is the connection object used throughout this example</li>
<li><span class="docutils literal"><span class="pre">error</span></span> is an error struct which is set when an error occurs</li>
<li><span class="docutils literal"><span class="pre">query</span></span> this is a constant containing the query we wish to execute</li>
<li><span class="docutils literal"><span class="pre">ret</span></span> is where the return code is store for the network functions</li>
<li><span class="docutils literal"><span class="pre">row</span></span> holds the row results</li>
<li><span class="docutils literal"><span class="pre">columns</span></span> and <span class="docutils literal"><span class="pre">current_column</span></span> are used for iterating though the result</li>
</ul>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">con</span><span class="o">=</span> <span class="n">attachsql_connect_create</span><span class="p">(</span><span class="s">"localhost"</span><span class="p">,</span> <span class="mi">3306</span><span class="p">,</span> <span class="s">"test"</span><span class="p">,</span> <span class="s">"test"</span><span class="p">,</span> <span class="s">"testdb"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</pre></div>
</div>
<p>This function creates the connection object.  A connection is not actually made at this point, we are just setting things up.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">error</span><span class="o">=</span> <span class="n">attachsql_query</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">query</span><span class="p">),</span> <span class="n">query</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</pre></div>
</div>
<p>This starts the process of connecting to the MySQL server and sending the query.  The last two parameters are for a way to escape data at the client end in a similar way to prepared statements.  I’ll cover this in another blog post.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">while</span> <span class="p">((</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">ATTACHSQL_RETURN_EOF</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
<span class="p">{</span>
  <span class="n">ret</span><span class="o">=</span> <span class="n">attachsql_connect_poll</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">error</span><span class="p">);</span>
</pre></div>
</div>
<p>This is where the magic happens.  Whilst we haven’t hit a query EOF or an error we are repeatedly polling the connection to see if we have have a row ready in the network buffer.</p>
<p>Not only this but a non-blocking DNS lookup, connection and handshake is made here, so it is likely poll will be called several times.  There is an API call to make the connection explicit rather than implicit on the first query and it will need to call <span class="docutils literal"><span class="pre">attachsql_connect_poll()</span></span> in the same way.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">ATTACHSQL_RETURN_ROW_READY</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If we don’t have a row yet continue polling until we do.  In a real-world application you can have other tasks on your main thread going on here and/or poll many connections on a single thread.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">row</span><span class="o">=</span> <span class="n">attachsql_query_row_get</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">error</span><span class="p">);</span>
</pre></div>
</div>
<p>Process the row and return an array of pointers to the network read buffer for parts of the row.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">columns</span><span class="o">=</span> <span class="n">attachsql_query_column_count</span><span class="p">(</span><span class="n">con</span><span class="p">);</span>

<span class="k">for</span> <span class="p">(</span><span class="n">current_column</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">current_column</span> <span class="o">&lt;</span> <span class="n">columns</span><span class="p">;</span> <span class="n">current_column</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%.*s "</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">row</span><span class="p">[</span><span class="n">current_column</span><span class="p">].</span><span class="n">length</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="n">current_column</span><span class="p">].</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
</pre></div>
</div>
<p>Iterate through the columns in the row and print out the result.  Technically we only need to call <span class="docutils literal"><span class="pre">attachsql_query_column_count()</span></span> once when the first row is ready in the buffer.</p>
<div class="highlight-cpp"><div class="highlight"><pre>  <span class="n">attachsql_query_row_next</span><span class="p">(</span><span class="n">con</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This tells the library that we are done with this row and are ready to retrieve the next, which brings us back to polling.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Error occurred: %s"</span><span class="p">,</span> <span class="n">error</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">);</span>
  <span class="n">attachsql_error_free</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If we have broken out of the loop due to an error, print that out and free the error object.</p>
<div class="highlight-cpp"><div class="highlight"><pre>  <span class="n">attachsql_query_close</span><span class="p">(</span><span class="n">con</span><span class="p">);</span>
  <span class="n">attachsql_connect_destroy</span><span class="p">(</span><span class="n">con</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Close the query and destroy the connection.  All done!</p>
]]></description>
            <category><![CDATA[ MySQL ]]></category>
            <category><![CDATA[ libAttachSQL ]]></category>
             <pubDate>Tue, 23 Sep 2014 00:00:00 +0100</pubDate>
        </item>
    
        <item>
            <link>http://linuxjedi.co.uk/blog/html/2014/09/23/new_blog.html</link>
            <guid>http://linuxjedi.co.uk/blog/html/2014/09/23/new_blog.html</guid>
            <title><![CDATA[New Blog!]]></title>
            <description><![CDATA[<h1>New Blog!</h1>
<p>Blogger is a great blogging platform.  Unfortunately it is really difficut to create content that has marked-up code in it.  Which as a developer is a requirement.  Therefore LinuxJedi’s /dev/null has now moved to this GitHub pages site using <a class="reference external" href="http://tinkerer.me">Tinkerer</a> to build it.</p>
<p>The old site and content can still be accessed at <a class="reference external" href="http://thelinuxjedi.blogspot.com">http://thelinuxjedi.blogspot.com/</a>.</p>
]]></description>
            <category><![CDATA[ General ]]></category>
             <pubDate>Tue, 23 Sep 2014 00:00:00 +0100</pubDate>
        </item>
    
    </channel>
</rss>