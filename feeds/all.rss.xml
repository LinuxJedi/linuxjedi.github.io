<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>LinuxJedi's /dev/null</title><link>http://linuxjedi.co.uk/</link><description>The /dev/null ramblings of a Linux Jedi</description><atom:link href="http://linuxjedi.co.uk/feeds/all.rss.xml" rel="self"></atom:link><lastBuildDate>Wed, 22 Oct 2014 11:35:00 +0200</lastBuildDate><item><title>libAttchSQL Hits First GA!</title><link>http://linuxjedi.co.uk/posts/2014/Oct/22/libattchsql-hits-first-ga/</link><description>&lt;p&gt;We have come a long way since the first code was put down for &lt;a class="reference external" href="http://libattachsql.org"&gt;libAttachSQL&lt;/a&gt; on the 4th July.  It has been a fantastic project to work on so I am very pleased to announce our first GA release.&lt;/p&gt;
&lt;p&gt;For those who haven't seen it so far libAttachSQL is a non-blocking, lightweight C API for MySQL servers.  It is Apache 2.0 licensed so is compatible with most Open Source and commercial licensing.  HP's Advanced Technology Group saw a need in this field not just for HP itself but for other companies and projects too.&lt;/p&gt;
&lt;p&gt;As for the GA release itself, there are not many changes over the RC release beyond stability fixes.  A full list can be seen in the &lt;a class="reference external" href="http://docs.libattachsql.org/en/latest/appendix/version_history.html#version-1-0"&gt;version history documentation&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In addition to the GA release we have recently had a driver for &lt;a class="reference external" href="https://launchpad.net/sysbench"&gt;Sysbench&lt;/a&gt; merged into their trunk so libAttachSQL can be used for benchmarking MySQL servers.  We have also started work on a tool called &lt;a class="reference external" href="https://github.com/libattachsql/attachbench"&gt;AttachBench&lt;/a&gt; which when complete will run similar MySQL tests as Sysbench but will allow for multiple connections per thread (something libAttachSQL excels at).  At the moment AttachBench requires the tables from Sysbench's &amp;quot;Select&amp;quot; test already setup and I don't recommend tinkering with it yet unless you don't mind getting a bit dirty.&lt;/p&gt;
&lt;p&gt;With the release of libAttachSQL 1.0.0 we have also launched a new website on &lt;a class="reference external" href="http://libattachsql.org"&gt;libattachsql.org&lt;/a&gt;.  It is a basic Pelican based site (very much like this blog) but will make it much easier for anyone to add content, just like this blog all the source is in &lt;a class="reference external" href="https://github.com/libattachsql/libattachsql.org"&gt;RST files on GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Download links for libAttachSQL 1.0.0 can be found on the &lt;a class="reference external" href="http://libattachsql.org/posts/2014/Oct/21/version-100-ga-released/"&gt;News section&lt;/a&gt; of the project website.  There is a source package as well as packages for RHEL/CentOS 6.x and 7.x.  Packages for Ubuntu 12.04 and 14.04 are waiting to be built in the PPA at time of posting.  We hope to have releases for more operating systems in the near future.&lt;/p&gt;
&lt;p&gt;Rest assured we are not stopping here.  I already have ideas of what I want to see in 1.1 and we have some spin-off projects planned.  If you would like to learn more please come along to my talk on libAttachSQL at &lt;a class="reference external" href="http://www.percona.com/live/london-2014/sessions/libattachsql-next-generation-c-connector-mysql"&gt;Percona Live London&lt;/a&gt;.  I'm also talking to several people outside of HP to see what they would like in libAttachSQL and am happy to talk to anyone else who wants to know more and has feedback.&lt;/p&gt;
&lt;p&gt;Many thanks to everyone who has helped us get this far.&lt;/p&gt;
</description><pubDate>Wed, 22 Oct 2014 11:35:00 +0200</pubDate><guid>tag:linuxjedi.co.uk,2014-10-22:posts/2014/Oct/22/libattchsql-hits-first-ga/</guid><category>MySQL</category><category>libAttachSQL</category><category>HP</category><category>Advanced Technology Group</category></item><item><title>libAttachSQL Single Thread vs. libmysqlclient Multi Thread</title><link>http://linuxjedi.co.uk/posts/2014/Oct/15/libattachsql-single-thread-vs-libmysqlclient-multi-thread/</link><description>&lt;p&gt;I have recently &lt;a class="reference external" href="http://linuxjedi.co.uk/posts/2014/Oct/03/libattachsql-benchmarks-with-sysbench/"&gt;posted up benchmarks&lt;/a&gt; of &lt;a class="reference external" href="http://libattachsql.org"&gt;libAttachSQL&lt;/a&gt; vs. libmysqlclient using sysbench.  Whilst these are great and shows the results I hoped for, this isn't what we designed libAttachSQL for.  It was designed for non-blocking many connections per thread.&lt;/p&gt;
&lt;p&gt;With this in mind I spent today knocking up a quick benchmark tool which replicates the Sysbench &amp;quot;Select&amp;quot; test but using libAttachSQL's connection groups on a single thread.  The code for this can be seen in the new &lt;a class="reference external" href="https://github.com/libattachsql/attachbench"&gt;AttachBench&lt;/a&gt; GitHub tree.  Of course the secondary reason for this is to try and hammer the connection groups feature, which of course did find a bug when I scaled to around 32 connections.  This has been fixed in libAttachSQL's master ready for the next release and is what I am using for these benchmarks.&lt;/p&gt;
&lt;div class="section" id="the-test"&gt;
&lt;h2&gt;The Test&lt;/h2&gt;
&lt;p&gt;I used the exact same test rig and configuration as the previous Sysbench tests and as before the test was run with 1,000,000 queries.  The AttachBench tool executed was as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;attachbench --db&lt;span class="o"&gt;=&lt;/span&gt;sbtest --user&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;test&lt;/span&gt; --pass&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;test&lt;/span&gt; --db&lt;span class="o"&gt;=&lt;/span&gt;testdb --queries&lt;span class="o"&gt;=&lt;/span&gt;1000000 --connections&lt;span class="o"&gt;=&lt;/span&gt;32 --host&lt;span class="o"&gt;=&lt;/span&gt;/tmp/mysql.sock --port&lt;span class="o"&gt;=&lt;/span&gt;0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I've added the results to the previous select test to the graph for comparison.  The two &amp;quot;Select&amp;quot; result sets are for Sysbench with one connection per thread.  The third is with AttachBench running the same queries, just with many connections in a single thread.&lt;/p&gt;
&lt;img alt="" src="/images/select_single_thread.png" /&gt;
&lt;p&gt;This exceeded my expectations.  Having many connections in a single thread actually outperforms many threads with one connection each.  It is early days and there is much more testing and improvement that can be done.  But I'm very encouraged by these results.&lt;/p&gt;
&lt;p&gt;I'll be talking more about libAttachSQL and these results at &lt;a class="reference external" href="http://www.percona.com/live/london-2014/sessions/libattachsql-next-generation-c-connector-mysql"&gt;Percona Live London next month&lt;/a&gt; so please come along if you are in the area.&lt;/p&gt;
&lt;/div&gt;
</description><pubDate>Wed, 15 Oct 2014 20:01:00 +0200</pubDate><guid>tag:linuxjedi.co.uk,2014-10-15:posts/2014/Oct/15/libattachsql-single-thread-vs-libmysqlclient-multi-thread/</guid><category>MySQL</category><category>libAttachSQL</category><category>HP</category><category>Advanced Technology Group</category></item><item><title>libAttachSQL 0.9.0 RC - Connection Groups</title><link>http://linuxjedi.co.uk/posts/2014/Oct/14/libattachsql-090-rc-connection-groups/</link><description>&lt;p&gt;It has been just over 4 months since I started working on &lt;a class="reference external" href="http://libattachsql.org"&gt;libAttachSQL&lt;/a&gt; for HP's Advanced Technology Group.  Today marks the first (and hopefully only) RC release of the library.&lt;/p&gt;
&lt;div class="section" id="connection-groups"&gt;
&lt;h2&gt;Connection Groups&lt;/h2&gt;
&lt;p&gt;The only real new feature that has been added to 0.9.0 is the concept of connection groups which is something I'm pretty excited about.  Internally libAttachSQL uses event loops to supply the non-blocking API.  Connection Groups join a bunch of connections together into a group that uses a single event loop.  This makes things much more efficient internally and makes applications easier to code too.&lt;/p&gt;
&lt;p&gt;Here is a simplified example of how to use it (for a more detailed example see our &lt;a class="reference external" href="http://docs.libattachsql.org/en/latest/api/examples.html#group-conncetions"&gt;example in the documentation&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;First we need to create the group and add connections to it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;group&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;attachsql_group_create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;con&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;attachsql_connect_create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;localhost&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3306&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;test&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;test&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;testdb&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;attachsql_group_add_connection&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;group&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;con&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;attachsql_connect_set_callback&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;con&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;callbk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;con_no&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;con&lt;/tt&gt; array is just an array of connection objects and &lt;tt class="docutils literal"&gt;con_no&lt;/tt&gt; is just an array of integers so that the callback that I'll show shortly knows which connection number it is (only useful for displaying in this example).  The last three lines there will be repeated multiple times with different array numbers to add connections.&lt;/p&gt;
&lt;p&gt;We now send queries to the connections:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;attachsql_query&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;con&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;strlen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;query1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;query1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;attachsql_query&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;con&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;strlen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;query2&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;query2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And so forth until we have sent a query to all the connections we want.&lt;/p&gt;
&lt;p&gt;Finally we want to run the connection group until complete:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;done_count&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;attachsql_group_run&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;group&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this example &lt;tt class="docutils literal"&gt;done_count&lt;/tt&gt; is simply a global integer which increments as each callback hits EOF.  You could conceivably run various other parts of your application here and then call &lt;tt class="docutils literal"&gt;attachsql_group_run()&lt;/tt&gt; again when ready.&lt;/p&gt;
&lt;p&gt;I'm going to paste the whole callback here because it should be mostly self-explanatory, it is called when an event occurs and the code reacts to the event:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;callbk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;attachsql_connect_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current_con&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;attachsql_events_t&lt;/span&gt; &lt;span class="n"&gt;events&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;attachsql_error_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;con_no&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint8_t&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;attachsql_query_row_st&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;uint16_t&lt;/span&gt; &lt;span class="n"&gt;columns&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;col&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;switch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;events&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;ATTACHSQL_EVENT_CONNECTED&lt;/span&gt;:
      &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Connected event on con %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;con_no&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;ATTACHSQL_EVENT_ERROR&lt;/span&gt;:
      &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Error exists on con %d: %d&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;con_no&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;attachsql_error_code&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
      &lt;span class="n"&gt;attachsql_error_free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;ATTACHSQL_EVENT_EOF&lt;/span&gt;:
      &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Connection %d finished&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;con_no&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="n"&gt;done_count&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="n"&gt;attachsql_query_close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current_con&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;ATTACHSQL_EVENT_ROW_READY&lt;/span&gt;:
      &lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;attachsql_query_row_get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current_con&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="n"&gt;columns&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;attachsql_query_column_count&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current_con&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;col&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;col&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;columns&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;col&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Con: %d, Column: %d, Length: %zu, Data: %.*s &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;con_no&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;col&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;col&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;col&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;col&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
      &lt;span class="n"&gt;attachsql_query_row_next&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current_con&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;ATTACHSQL_EVENT_NONE&lt;/span&gt;:
      &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The EOF call happens when we reach the end of the result set.  You could easily make this a job server here sending more queries when the previous queries are complete.  ROW_READY should be familiar to anyone who has seen previous examples of libAttachSQL.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="release-and-packages"&gt;
&lt;h2&gt;Release and Packages&lt;/h2&gt;
&lt;p&gt;libAttachSQL 0.9.0RC is out today, there is a source release as well as packages for RHEL &amp;amp; CentOS 6/7 64bit as well as an Ubuntu PPA 12.04/14.04 32bit and 64bit.  Links to all these can be found on the news section of the &lt;a class="reference external" href="http://libattachsql.org/"&gt;libAttachSQL site&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
</description><pubDate>Tue, 14 Oct 2014 17:14:00 +0200</pubDate><guid>tag:linuxjedi.co.uk,2014-10-14:posts/2014/Oct/14/libattachsql-090-rc-connection-groups/</guid><category>MySQL</category><category>libAttachSQL</category><category>HP</category><category>Advanced Technology Group</category></item><item><title>libAttachSQL Second Beta, After the Sledgehammer</title><link>http://linuxjedi.co.uk/posts/2014/Oct/08/libattachsql-second-beta-after-the-sledgehammer/</link><description>&lt;p&gt;Last week I &lt;a class="reference external" href="http://linuxjedi.co.uk/posts/2014/Oct/03/libattachsql-benchmarks-with-sysbench/"&gt;blogged about getting sysbench working with libAttachSQL&lt;/a&gt;.  This was not only an exercise in performance but also the first real test for &lt;a class="reference external" href="http://libattachsql.org/"&gt;libAttachSQL&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Before I had done this testing the most the early Alpha and Beta releases of libAttachSQL had gone through is a few basic queries.  So, the first thing I did when I got the sysbench driver working was slap it with 1,000,000 queries.  It pretty much exploded instantly on that.  Over the course of this release I have probably hit it with over 100,000,000 queries and things run a lot smoother.&lt;/p&gt;
&lt;p&gt;This has led to today's release of libAttachSQL 0.5.0.  As far as changes go this release has the &lt;a class="reference external" href="http://docs.libattachsql.org/en/latest/appendix/version_history.html#version-0-5"&gt;biggest changelog so far&lt;/a&gt;.  Here is a summary of the major points:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;11 major bugs fixes, most of them crashing bugs&lt;/li&gt;
&lt;li&gt;Lots more documentation and examples&lt;/li&gt;
&lt;li&gt;More tests&lt;/li&gt;
&lt;li&gt;A couple of minor features&lt;/li&gt;
&lt;li&gt;A new semi-blocking mode&lt;/li&gt;
&lt;li&gt;A more consistent API for error handling&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These last two points I should talk about a bit more.  The semi-blocking mode lets the networking code block until data is received (but not until it is all received).  For applications which access using one connection per thread this will increase performance, but will decrease performance for many connections per thread (which is what libAttachSQL was originally designed for).&lt;/p&gt;
&lt;p&gt;The error handling has moved from a user accessible struct to a type which is used in function calls.  In addition the way this is returned to the user application has been made consistent across the whole API.  This means that the API is not backwards compatible with 0.4.0.&lt;/p&gt;
&lt;p&gt;For those wishing to try out the connector the 0.5.0 beta source release &lt;a class="reference external" href="https://github.com/libattachsql/libattachsql/releases/tag/v0.5.0"&gt;can be found on GitHub&lt;/a&gt;.  The documentation is on &lt;a class="reference external" href="http://docs.libattachsql.org/en/latest/"&gt;Read The Docs&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This will be the last beta for libAttachSQL.  The next release will be 0.9.0 RC which will hopefully be a short cycle to our first GA release.  We have many more goodies planned after GA.  Watch this space!&lt;/p&gt;
&lt;p&gt;As always if you have any questions please get in touch either via. the comments below, the &lt;a class="reference external" href="irc://chat.freenode.net/libAttachSQL"&gt;#libAttachSQL Freenode channel&lt;/a&gt; or any other means.&lt;/p&gt;
</description><pubDate>Wed, 08 Oct 2014 20:52:00 +0200</pubDate><guid>tag:linuxjedi.co.uk,2014-10-08:posts/2014/Oct/08/libattachsql-second-beta-after-the-sledgehammer/</guid><category>MySQL</category><category>libAttachSQL</category><category>HP</category><category>Advanced Technology Group</category></item><item><title>Blogging Platforms</title><link>http://linuxjedi.co.uk/posts/2014/Oct/04/blogging-platforms/</link><description>&lt;p&gt;A couple of weeks ago I ditched Blogger as my main blogging platform.  The main reason for this was the editing tools were breaking posts containing code.  Whilst it is a great platform for basic blogging, it is not suitable for developers blogs.&lt;/p&gt;
&lt;p&gt;So, I was on the hunt for blogging platforms that would make it easy for me to write posts that contain technical content and is not expensive to run.  I also don't want to be maintaining my own web server, I may be capable of doing this but I don't want the time overhead.&lt;/p&gt;
&lt;p&gt;I tried several things out that met some of my requirements but many didn't fit all.  Wordpress was probably the closest, but I had trouble bending the free templates to my will.&lt;/p&gt;
&lt;p&gt;With many on my team at HP's Advanced Technology Group using &lt;a class="reference external" href="https://pages.github.com/"&gt;GitHub Pages&lt;/a&gt; for blog posts I thought I would give it a try.  Most of the team are trying out Jekyll which looks really good, but isn't for me.  I prefer &lt;a class="reference external" href="http://docutils.sourceforge.net/rst.html"&gt;reStructuredText&lt;/a&gt; to Markdown and use it every day for the &lt;a class="reference external" href="http://docs.libattachsql.org"&gt;libAttachSQL documentation&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;On my journey I came across &lt;a class="reference external" href="http://tinkerer.me/"&gt;Tinkerer&lt;/a&gt; which is a layer on top of &lt;a class="reference external" href="http://sphinx-doc.org/"&gt;Python Sphinx&lt;/a&gt; to generate a blog site from RST files.  This was great for me because Sphinx is the renderer used for libAttachSQL's docs both in the build system and &lt;a class="reference external" href="https://readthedocs.org/"&gt;Read The Docs&lt;/a&gt;.  I created a new blog on this hosted on GitHub Pages and &lt;a class="reference external" href="https://disqus.com/"&gt;Disqus&lt;/a&gt; for comments.&lt;/p&gt;
&lt;p&gt;I had several minor problems with Tinkerer, many of which I worked around, but the main flaw was no timestamp support for blog posts.  All blog posts would have a date but not a time, so in the RSS feeds it would be as if they were posted at midnight.  If you are posting at 22:00 it means in feed aggregators your post would end up below many others posted that day and multiple posts in a day could be in any order.&lt;/p&gt;
&lt;p&gt;Today I bumped into a blogging platform called &lt;a class="reference external" href="http://blog.getpelican.com/"&gt;Pelican&lt;/a&gt;.  It too uses RST files to generate the site, but supports metadata in the RST files to signify things such as time of post.  It was incredibly easy to port my Tinkerer posts over so I gave it a try.&lt;/p&gt;
&lt;p&gt;I have ended up with generation scripts, RST files and a theme I have modified in a &lt;a class="reference external" href="https://github.com/LinuxJedi/linuxjedi.co.uk"&gt;GitHub repo&lt;/a&gt; and the generated content in my &lt;a class="reference external" href="https://github.com/LinuxJedi/linuxjedi.github.io"&gt;GitHub Pages Repo&lt;/a&gt;.  Pelican has a built-in HTTP server which makes it easy to preview your generated HTML before it is uploaded to the site.&lt;/p&gt;
&lt;p&gt;In conclusion, Tinkerer is a great platform, but Pelican feels more mature and it seems to have a wider community around it.  I also found its templates much easier to edit.  Both platforms have an Open Source feel to the way you create and publish content which is fantastic for my usage.  I think I have finally found a blogging platform I can settle with.&lt;/p&gt;
</description><pubDate>Sat, 04 Oct 2014 22:16:00 +0200</pubDate><guid>tag:linuxjedi.co.uk,2014-10-04:posts/2014/Oct/04/blogging-platforms/</guid><category>Blog</category><category>LinuxJedi</category></item><item><title>libAttachSQL Benchmarks With Sysbench</title><link>http://linuxjedi.co.uk/posts/2014/Oct/03/libattachsql-benchmarks-with-sysbench/</link><description>&lt;p&gt;This week I have been spending a little bit of time creating a module for &lt;a class="reference external" href="https://launchpad.net/sysbench"&gt;Sysbench&lt;/a&gt; so that it can use &lt;a class="reference external" href="http://libattachsql.org/"&gt;libAttachSQL&lt;/a&gt; as a database driver.  The reason for doing this is twofold:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://krow.net/"&gt;Brian&lt;/a&gt; (my boss at HP's Advanced Technology Group) said now would be a good time to benchmark libAttachSQL&lt;/li&gt;
&lt;li&gt;I really needed more than a few basic queries to shake out bugs in the library, and a benchmark is a good way to shove a few million through it&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;On the bug front, it did find a total of 5 bugs, a couple of them serious.  Which is great, the more testing and bug finding the better.  These have all been fixed in &lt;a class="reference external" href="http://github.com/libattachsql/libattachsql"&gt;GitHub&lt;/a&gt; and will be part of the upcoming 0.5.0 release.&lt;/p&gt;
&lt;div class="section" id="the-test-setup"&gt;
&lt;h2&gt;The Test Setup&lt;/h2&gt;
&lt;p&gt;To benchmark I used an HP Z620, 6-core Xeon with 16GB RAM and an SSD.  The OS was Antergos Linux (Arch with a nicer theme) and the server was MySQL 5.6.20 compiled from source.  The only real tweaks I've made to the out-of-box config that would make any difference are:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="na"&gt;innodb_buffer_pool_size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;3G&lt;/span&gt;
&lt;span class="na"&gt;innodb_locks_unsafe_for_binlog&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;1&lt;/span&gt;
&lt;span class="na"&gt;innodb_buffer_pool_instances&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;8&lt;/span&gt;
&lt;span class="na"&gt;thread_cache&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;256&lt;/span&gt;
&lt;span class="na"&gt;query_cache_type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;0&lt;/span&gt;
&lt;span class="na"&gt;query_cache_size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;0&lt;/span&gt;
&lt;span class="na"&gt;max_connections&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;20020&lt;/span&gt;
&lt;span class="na"&gt;max_user_connections&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;20000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;a class="reference external" href="https://github.com/libattachsql/sysbench"&gt;Sysbench in libAttachSQL's GitHub&lt;/a&gt; was used which just has the additional driver for libAttachSQL.  Once I'm 100% happy with the driver I offer it as an upstream branch.  libAttachSQL master is used, partly due to the bug fixes and partly because there has been a large API change in master for improved error handling.&lt;/p&gt;
&lt;p&gt;For both libmysqlclient and libAttachSQL the connections were made using Unix Domain Sockets.  For the sysbench setup I just left it at the default number of rows.  The Sysbench driver for libAttachSQL enables the semi-blocking mode which is better performance for single-connection-per-thread applications.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="select-test"&gt;
&lt;h2&gt;Select Test&lt;/h2&gt;
&lt;p&gt;First the basic select test was run, which queries for random single integers in a table.  This was run with the MySQL driver as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sysbench --test&lt;span class="o"&gt;=&lt;/span&gt;sysbench/tests/db/select.lua --db-driver&lt;span class="o"&gt;=&lt;/span&gt;mysql --mysql-socket&lt;span class="o"&gt;=&lt;/span&gt;/tmp/mysql.sock --mysql-user&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;test&lt;/span&gt; --mysql-password&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;test&lt;/span&gt; --mysql-db&lt;span class="o"&gt;=&lt;/span&gt;testdb --num-threads&lt;span class="o"&gt;=&lt;/span&gt;8 --max-requests&lt;span class="o"&gt;=&lt;/span&gt;1000000 run
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And libAttachSQL:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sysbench --test&lt;span class="o"&gt;=&lt;/span&gt;sysbench/tests/db/select.lua --db-driver&lt;span class="o"&gt;=&lt;/span&gt;attachsql --attachsql-socket&lt;span class="o"&gt;=&lt;/span&gt;/tmp/mysql.sock --attachsql-user&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;test&lt;/span&gt; --attachsql-password&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;test&lt;/span&gt; --attachsql-db&lt;span class="o"&gt;=&lt;/span&gt;testdb --num-threads&lt;span class="o"&gt;=&lt;/span&gt;8 --max-requests&lt;span class="o"&gt;=&lt;/span&gt;1000000 run
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The results were as follows:&lt;/p&gt;
&lt;img alt="" src="/images/select_benchmark.png" /&gt;
&lt;p&gt;I am pretty impressed with these results so far, since I have done no optimisation work on the code.  I originally wanted the first GA to have performance on-par with libmysqlclient and it looks like that goal has been met.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="select-random-points"&gt;
&lt;h2&gt;Select Random Points&lt;/h2&gt;
&lt;p&gt;I used the &amp;quot;Select Random Points&amp;quot; benchmark because it is one of the only ones that comes with Sysbench which uses Prepared Statements.  It selects 10 random integers from a table per query.&lt;/p&gt;
&lt;p&gt;As before this was run on using libmysqlclient with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sysbench --test&lt;span class="o"&gt;=&lt;/span&gt;sysbench/tests/db/select_random_points.lua --db-driver&lt;span class="o"&gt;=&lt;/span&gt;mysql --mysql-socket&lt;span class="o"&gt;=&lt;/span&gt;/tmp/mysql.sock --mysql-user&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;test&lt;/span&gt; --mysql-password&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;test&lt;/span&gt; --mysql-db&lt;span class="o"&gt;=&lt;/span&gt;testdb --num-threads&lt;span class="o"&gt;=&lt;/span&gt;8 --max-requests&lt;span class="o"&gt;=&lt;/span&gt;1000000 run
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And with libAttachSQL:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sysbench --test&lt;span class="o"&gt;=&lt;/span&gt;sysbench/tests/db/select_random_points.lua --db-driver&lt;span class="o"&gt;=&lt;/span&gt;attachsql --attachsql-socket&lt;span class="o"&gt;=&lt;/span&gt;/tmp/mysql.sock --attachsql-user&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;test&lt;/span&gt; --attachsql-password&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;test&lt;/span&gt; --attachsql-db&lt;span class="o"&gt;=&lt;/span&gt;testdb --num-threads&lt;span class="o"&gt;=&lt;/span&gt;8 --max-requests&lt;span class="o"&gt;=&lt;/span&gt;1000000 run
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The results were as follows:&lt;/p&gt;
&lt;img alt="" src="/images/select_random_points_benchmark.png" /&gt;
&lt;p&gt;Again there isn't a lot in it.  libmysqlclient is edging slightly over libAttachSQL in most of this chart.  I believe it is because in the libAttachSQL driver I told it to convert all results to string outputs.  This will add additional overhead.  Next week I will tweak the driver to make sure that the conversion isn't done.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;I'm very happy with these Sysbench tests because not only has it bashed libAttachSQL with a sledgehammer it has given me some idea of the performance.  I'm happy enough with these figures to not do any performance tuning until after the first GA release.&lt;/p&gt;
&lt;p&gt;At some point soon I will also benchmark the single-threaded multi-connection performance of libAttachSQL.  This is not something I can easily compare to libmysqlclient (there is an API to do it, but it is an unofficial/unsupported API).  But it will be a good test for the use case I originally designed the library for.&lt;/p&gt;
&lt;p&gt;I am no benchmarking expert and I know many of you who reading this are (especially Percona).  Is there anything I missed or could have done better?  Please let me know in the comments.&lt;/p&gt;
&lt;/div&gt;
</description><pubDate>Fri, 03 Oct 2014 21:28:00 +0200</pubDate><guid>tag:linuxjedi.co.uk,2014-10-03:posts/2014/Oct/03/libattachsql-benchmarks-with-sysbench/</guid><category>MySQL</category><category>libAttachSQL</category><category>HP</category><category>Advanced Technology Group</category></item><item><title>libAttachSQL Query Example</title><link>http://linuxjedi.co.uk/posts/2014/Sep/23/libattachsql-query-example/</link><description>&lt;p&gt;I was asked some questions on IRC last night about how the query example in libAttachSQL's code base works.  For those who missed previous posts, &lt;a class="reference external" href="http://libattachsql.org/"&gt;libAttachSQL&lt;/a&gt; is a lightweight, non-blocking, Apache 2.0 licensed C connector for MySQL servers which I am developing for HP's Advanced Technology Group.&lt;/p&gt;
&lt;p&gt;In this blog post I'm going to break down &lt;a class="reference external" href="https://github.com/libattachsql/libattachsql/blob/master/examples/basic_query.c"&gt;a basic query example&lt;/a&gt; and explain what is happening at each step. It is possible that this syntax may change slightly by the time we hit GA but it will be similar to this.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;libattachsql-1.0/attachsql.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;stddef.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;string.h&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Only one include is needed for the library itself, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;libattachsql-1.0/attachsql.h&lt;/span&gt;&lt;/tt&gt;. The others are used for other functions in the code.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;attachsql_connect_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;con&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;attachsql_error_st&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;SELECT * FROM t1 WHERE name=&amp;#39;fred&amp;#39;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;attachsql_return_t&lt;/span&gt; &lt;span class="n"&gt;ret&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ATTACHSQL_RETURN_NONE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;attachsql_query_row_st&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;uint16_t&lt;/span&gt; &lt;span class="n"&gt;columns&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;current_column&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here we have setup a few required variables:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;con&lt;/tt&gt; is the connection object used throughout this example&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;error&lt;/tt&gt; is an error struct which is set when an error occurs&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;query&lt;/tt&gt; this is a constant containing the query we wish to execute&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;ret&lt;/tt&gt; is where the return code is store for the network functions&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;row&lt;/tt&gt; holds the row results&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;columns&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;current_column&lt;/tt&gt; are used for iterating though the result&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;con&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;attachsql_connect_create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;localhost&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3306&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;test&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;test&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;testdb&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This function creates the connection object.  A connection is not actually made at this point, we are just setting things up.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;attachsql_query&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;con&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;strlen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This starts the process of connecting to the MySQL server and sending the query.  The last two parameters are for a way to escape data at the client end in a similar way to prepared statements.  I'll cover this in another blog post.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;ret&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;ATTACHSQL_RETURN_EOF&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;ret&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;attachsql_connect_poll&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;con&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is where the magic happens.  Whilst we haven't hit a query EOF or an error we are repeatedly polling the connection to see if we have have a row ready in the network buffer.&lt;/p&gt;
&lt;p&gt;Not only this but a non-blocking DNS lookup, connection and handshake is made here, so it is likely poll will be called several times.  There is an API call to make the connection explicit rather than implicit on the first query and it will need to call &lt;tt class="docutils literal"&gt;attachsql_connect_poll()&lt;/tt&gt; in the same way.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ret&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;ATTACHSQL_RETURN_ROW_READY&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;continue&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If we don't have a row yet continue polling until we do.  In a real-world application you can have other tasks on your main thread going on here and/or poll many connections on a single thread.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;attachsql_query_row_get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;con&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Process the row and return an array of pointers to the network read buffer for parts of the row.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;columns&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;attachsql_query_column_count&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;con&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current_column&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;current_column&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;columns&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;current_column&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%.*s &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;current_column&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;current_column&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Iterate through the columns in the row and print out the result.  Technically we only need to call &lt;tt class="docutils literal"&gt;attachsql_query_column_count()&lt;/tt&gt; once when the first row is ready in the buffer.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="n"&gt;attachsql_query_row_next&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;con&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This tells the library that we are done with this row and are ready to retrieve the next, which brings us back to polling.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Error occurred: %s&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;attachsql_error_free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If we have broken out of the loop due to an error, print that out and free the error object.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="n"&gt;attachsql_query_close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;con&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;attachsql_connect_destroy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;con&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Close the query and destroy the connection.  All done!&lt;/p&gt;
</description><pubDate>Tue, 23 Sep 2014 23:02:00 +0200</pubDate><guid>tag:linuxjedi.co.uk,2014-09-23:posts/2014/Sep/23/libattachsql-query-example/</guid><category>MySQL</category><category>libAttachSQL</category><category>HP</category><category>Advanced Technology Group</category></item><item><title>New Blog!</title><link>http://linuxjedi.co.uk/posts/2014/Sep/23/new-blog/</link><description>&lt;p&gt;Blogger is a great blogging platform.  Unfortunately it is really difficut to create content that has marked-up code in it.  Which as a developer is a requirement.  Therefore LinuxJedi's /dev/null has now moved to this GitHub pages site using &lt;a class="reference external" href="http://tinkerer.me/"&gt;Tinkerer&lt;/a&gt; to build it.&lt;/p&gt;
&lt;p&gt;The old site and content can still be accessed at &lt;a class="reference external" href="http://thelinuxjedi.blogspot.com/"&gt;http://thelinuxjedi.blogspot.com/&lt;/a&gt;.&lt;/p&gt;
</description><pubDate>Tue, 23 Sep 2014 16:45:00 +0200</pubDate><guid>tag:linuxjedi.co.uk,2014-09-23:posts/2014/Sep/23/new-blog/</guid><category>LinuxJedi</category></item></channel></rss>